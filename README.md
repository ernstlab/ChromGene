# ChromGene: Gene-Based Modelling of Epigenomic Data

## Design
ChromGene is a method for annotating genomic intervals by modeling them as arising from a mixture of Hidden Markov Models (HMMs). As with a Gaussian Mixture Model, where each point is assumed to have been generated by exactly one Gaussian distribution, each gene is assumed to be generated by exactly one HMM. Each HMM is fully-connected, and is defined by emission parameters of each of S states, the transition parameters between them, and the prior probabilities of each state.

## Usage
ChromGene can be applied to any genomic intervals where histone marks and DNA accessibility tracks are expected to vary across the genome by modifying the provided code.

We applied ChromGene to a set of 19,919 protein-coding genes across 127 imputed epigenomes (Frankish et al. 2018, Roadmap Epigenomics Consortium et al. 2015). The full set of annotations is reported in this repository, and their descriptions and various metrics are reported in Supp. Table 1. Along with the annotations, we have included code to generate input files to use on top of ChromHMM (Ernst and Kellis, 2015), and to generate a ChromGene assignment matrix.

Usage requires only basic Python packages, which can be easily installed with Anaconda or pip.

First, create the input binary files to use on top of ChromHMM. This will require either a GTF or BED file to demarcate the positions of genes:
```
python generate_chromgene_input_files.py \
annotation [path to bed or gtf file] \
mark_files [ChromHMM chromatin mark binary call file paths] \
--num_states [number of states per mixture; default: 3] \
--num_mixtures [number of mixtures; default: 12] \
--binary [whether to output binary files, can be set to False for testing; default: True] \
--model_param [whether to output model param files, can be set to False for testing; default: True] \
--resolution [resolution of data to output; default: 200] \
--subsample [fraction to subsample positions to initialize ChromGene emission parameters; default: 1] \
--window [bases to go up/downstream of TSS/TES for flanking regions; default: 2000] \
--output_tss [only output TSS binary; default: False] \
--out_dir [output directory; default="."] \
--verbose [verbose; default: False]
```

Second, run ChromHMM on the binary files, passing the model file and binaries deposited into `out_dir`. The argument `total_num_states` should be (num_mixtures * num_states) + 1
`java -jar -mx24000M  path/to/ChromHMM.jar LearnModel -b 200 -d -1 -gzip -holdcolumnorder -holdroworder -init load -m path_to_model_file/model_n.txt -n 100 -lowmem -printstatebyline ./binaries/chromgene_binaries ./out_dir total_num_states hg19`

Finally, create the ChromGene mixture assignments. This will create .npy files and .txt files
```
python chromgene_posteriors_to_mixtures.py
--segmentation_dir [directory with segmentation files; default: '.']
--states_per_mixture [number of states per mixture; default: 4]
--out_dir [directory in which to save data; default: '.']
```
